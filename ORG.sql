use ORG;

SELECT * FROM WORKER;
SELECT * FROM TITLE;
SELECT * FROM TITLE;
CREATE TABLE BONUS (
    WORKER_REF_ID INT,
    BONUS_AMOUNT NUMBER(10),
    BONUS_DATE DATE,
    FOREIGN KEY(WORKER_REF_ID) REFERENCES WORKER(WORKER_ID) ON DELETE CASCADE
);

INSERT ALL  
    INTO BONUS(WORKER_REF_ID, BONUS_AMOUNT, BONUS_DATE) VALUES
        (1, 5000, TO_DATE('16-02-2020','DD-MM-YYYY'))  
    INTO BONUS(WORKER_REF_ID, BONUS_AMOUNT, BONUS_DATE) VALUES
        (2, 3000, TO_DATE('16-02-2020','DD-MM-YYYY'))  
    INTO BONUS(WORKER_REF_ID, BONUS_AMOUNT, BONUS_DATE) VALUES
        (3, 4000, TO_DATE('16-02-2020','DD-MM-YYYY'))  
    INTO BONUS(WORKER_REF_ID, BONUS_AMOUNT, BONUS_DATE) VALUES
        (1, 4500, TO_DATE('16-02-2020','DD-MM-YYYY'))  
    INTO BONUS(WORKER_REF_ID, BONUS_AMOUNT, BONUS_DATE) VALUES
        (2, 3500, TO_DATE('16-02-2020','DD-MM-YYYY'))  
SELECT 1 FROM DUAL;

 INSERT INTO TITLE (WORKER_REF_ID, WORKER_TITLE, AFFECTED_FROM) VALUES (1, 'Manager', TO_DATE('2016-02-20 00:00:00', 'YYYY-MM-DD HH24:MI:SS'));
INSERT INTO TITLE (WORKER_REF_ID, WORKER_TITLE, AFFECTED_FROM) VALUES (2, 'Executive', TO_DATE('2016-06-11 00:00:00', 'YYYY-MM-DD HH24:MI:SS'));
INSERT INTO TITLE (WORKER_REF_ID, WORKER_TITLE, AFFECTED_FROM) VALUES (8, 'Executive', TO_DATE('2016-06-11 00:00:00', 'YYYY-MM-DD HH24:MI:SS'));
INSERT INTO TITLE (WORKER_REF_ID, WORKER_TITLE, AFFECTED_FROM) VALUES (5, 'Manager', TO_DATE('2016-06-11 00:00:00', 'YYYY-MM-DD HH24:MI:SS'));
INSERT INTO TITLE(WORKER_REF_ID, WORKER_TITLE, AFFECTED_FROM) VALUES (4, 'Asst. Manager', TO_DATE('2016-06-11 00:00:00', 'YYYY-MM-DD HH24:MI:SS'));
INSERT INTO TITLE(WORKER_REF_ID, WORKER_TITLE, AFFECTED_FROM) VALUES (7, 'Executive', TO_DATE('2016-06-11 00:00:00', 'YYYY-MM-DD HH24:MI:SS'));
INSERT INTO TITLE(WORKER_REF_ID, WORKER_TITLE, AFFECTED_FROM) VALUES (6, 'Lead', TO_DATE('2016-06-11 00:00:00', 'YYYY-MM-DD HH24:MI:SS'));
INSERT INTO TITLE(WORKER_REF_ID, WORKER_TITLE, AFFECTED_FROM) VALUES (3, 'Lead', TO_DATE('2016-06-11 00:00:00', 'YYYY-MM-DD HH24:MI:SS'));

-- Commit the changes
COMMIT;


--Q6,7. REMOVING WHITE SPACES 
--RIGHT
SELECT RTRIM(FIRST_NAME) FROM WORKER;
--LEFT
SELECT LTRIM(FIRST_NAME) FROM WORKER;

 --Q8. QUERY TO GET UNIQUE VALUES OF DEPARTMENT FORM WORKER TABLE AND PRINT ITS LENGTH
 SELECT DISTINCT DEPARTMENT,LENGTH(DEPARTMENT) FROM WORKER;
 
 --Q9. QUERY TO REPLACE a WITH A IN WORKER TABLE FIRST_NAME COLUMN
 SELECT REPLACE(FIRST_NAME,'a', 'A') FROM WORKER;

--Q10. QUERY TO WRITE BOTH FIRST AND LAST NAME IN ONE SEPERATED BY SPACE 
SELECT FIRST_NAME ||LAST_NAME AS FULL_NAME FROM WORKER ;
SELECT CONCAT(FIRST_NAME,LAST_NAME)AS FULL_NAME FROM WORKER;

--Q11. PRINT ALL WORKERS DETAILS FROM WORKER TABLE ORDER BY FIRST_NAME
SELECT * FROM WORKER ORDER BY FIRST_NAME;

--Q12. PRINT ALL WORKER DETAILS FROM WORKER TABLE ORDER BY 
-- FIRST_NAME ASEC, DEPARTMENT DESC
SELECT * FROM WORKER ORDER BY FIRST_NAME ASC, DEPARTMENT DESC;

--Q13. PRINT ALL FIRST NAME 'MISHRA', 'ARORA'
SELECT * FROM WORKER WHERE FIRST_NAME IN('Monika','Neha');

--Q14. excluding 'Monika','Neha'
SELECT * FROM WORKER WHERE FIRST_NAME NOT IN('Monika','Neha');

--Q15. PRINT ALL WORKER DETAILS WITH DEPARTMENT ADMIN
SELECT * FROM WORKER WHERE DEPARTMENT like 'Admin%';

--Q16. PRINT ALL WORKERS WHOSE FIRST_NAME CONTAINS A
SELECT * FROM WORKER WHERE FIRST_NAME LIKE 'A%';

--Q17. NAMES END WITH A
SELECT * FROM WORKER WHERE FIRST_NAME LIKE '%a';

--Q18. FIRST NAME ENDDS WITH H AND CONTAINS SIX ALPHABETS 
SELECT * FROM WORKER WHERE FIRST_NAME LIKE '_____a%';

--Q19. SALARY LIES BETWEEN 50 TO 80K
SELECT * FROM WORKER WHERE SALARY BETWEEN 50000 AND 90000;

--Q20. WHO HAVE JOINES IN FEB 2024
SELECT * FROM WORKER WHERE EXTRACT(YEAR FROM JOINING_DATE) = 21 AND EXTRACT(MONTH FROM JOINING_DATE)= 1;
SELECT * FROM WORKER 
WHERE TO_CHAR(JOINING_DATE, 'YYYY') = '21' 
AND TO_CHAR(JOINING_DATE, 'MM') = '01';

--Q21. COUNT EMPLOYEES WORKING IN DEPARTMENT ADMIN 
SELECT DEPARTMENT,COUNT(*) FROM WORKER WHERE DEPARTMENT LIKE 'Admin%'
    GROUP BY DEPARTMENT;

--Q22. FETCH FULL NAMES IF SALARY IS GRATER THAN 50000 AND LESS THAN 100000;
SELECT FIRST_NAME || ' ' || LAST_NAME FROM WORKER WHERE SALARY BETWEEN 50000 AND 100000;

--Q23. FETCH NO. OF WORKER IN EACH DEPARTMENT IN DESC
SELECT DEPARTMENT,COUNT(WORKER_ID) AS WORKERS FROM WORKER
    GROUP BY DEPARTMENT  ORDER BY WORKERS DESC;
    
--Q24. PRINT DETAILS OF WHO ARE ALSO MANAGER 
SELECT W.* FROM WORKER W 
        INNER JOIN 
        TITLE T ON 
 W.WORKER_ID = T.WORKER_REF_ID WHERE T.WORKER_TITLE='Manager'; 
 
 --Q25. QUERY TO FETCH NUMBER (MORE THAN 1) DIFFERENT TITLES IN THE ORG.
SELECT WORKER_TITLE, COUNT(*) AS NO_OF_EMPLOYEE FROM TITLE GROUP BY WORKER_TITLE HAVING COUNT(*)>1;

--Q26. QUERY TO SHOW ONLY ODD ROWS FROM A TABLE 
SELECT * FROM WORKER 
    WHERE MOD(WORKER_ID,2)!=0;

SELECT * FROM WORKER 
    WHERE MOD(WORKER_ID,2)<>0;
    
--Q27. QUERY TO SHOW ONLY EVEN ROWS FROM TABLE
SELECT * FROM WORKER 
    WHERE MOD(WORKER_ID,2)=0;
    
--Q28. QUERY TO CLONE A NEW TABLE 
CREATE TABLE WORKER_CLONE LIKE WORKER;

--ORACLE 
CREATE TABLE WORKER_CLONE AS 
    SELECT * FROM WORKER;
    
INSERT INTO WORKER_CLONE SELECT * FROM WORKER;

--Q29.  INSERTION RECORDS OF TWO TABLES
SELECT WORKER.* FROM WORKER 
    INNER JOIN WORKER_CLONE ON (WORKER.WORKER_ID)= WORKER_CLONE.WORKER_ID;
    
--Q30. QUERY TO SHOW RECORDS FROM ONE TABLE THAT DONOT IN ANOTHER TABLE 
SELECT WORKER.* FROM WORKER LEFT JOIN 
    WORKER_CLONE ON WORKER.WORKER_ID = WORKER_CLONE.WORKER_ID
    WHERE WORKER_CLONE.WORKER_ID IS NULL; 

--Q31. SHOW CURRENT DATE AND TIME 
SELECT SYSDATE FROM DUAL;

SELECT SYSTIMESTAMP FROM DUAL;

--Q32. TOP 5 RECORDS IN DESC
SELECT * FROM WORKER ORDER BY SALARY DESC LIMIT(5);
--ORACLE SQL
SELECT * FROM WORKER ORDER BY SALARY DESC FETCH FIRST 5 ROWS ONLY;

--Q33. TOP 5 HIGHEST SALARY IN THE 
SELECT * FROM WORKER ORDER BY SALARY DESC FETCH FIRST 1 ROWS ONLY;

--Q34. 5TH HIGHEST WITHOUT LINIT 
--CORELATED SUBQUERY 
SELECT * FROM WORKER W1
WHERE 4=(
    SELECT COUNT(DISTINCT (W2.SALARY))FROM WORKER W2
    WHERE W2.SALARY>= W1.SALARY
);

--Q35. EMPLOYEES WITH SAME SALARY 
SELECT W1.* FROM WORKER W1, WORKER W2 
    WHERE W1.SALARY != W2.SALARY
    AND W1.WORKER_ID != W2.WORKER_ID;


SELECT DISTINCT SALARY FROM WORKER 
ORDER BY SALARY DESC 
FETCH FIRST 1 ROWS OFFSET 1;

--Q36. TO SHOW THE SECOND HIGHEST SALARY USING SUBQUERY 
SELECT MAX(SALARY) FROM WORKER
WHERE SALARY NOT IN (SELECT MAX(SALARY)FROM WORKER
    WHERE SALARY NOT IN (SELECT MAX(SALARY)FROM WORKER) );

--Q37. QUERY TO SHOW ONE ROW 2 TIMES 
SELECT * FROM WORKER 
UNION ALL
SELECT * FROM WORKER 
ORDER BY WORKER_ID AS A;

--Q.38 QUERY WOKERS WHO DO NOT GETS  BONUS 
SELECT WORKER_ID, FIRST_NAME FROM WORKER WHERE WORKER_ID
NOT IN (SELECT WORKER_REF_ID FROM BONUS)ORDER BY WORKER_ID;

--Q.39 FETCH 50% TUPPLE 
SELECT * FROM WORKER WHERE WORKER_ID<= (SELECT COUNT(WORKER_ID)/2 FROM WORKER);

--Q.40 DEPARTMENT THAT HAVE LESS THAN 4 PEOPLE IN IT. 
SELECT DEPARTMENT ,COUNT(DEPARTMENT) AS DEPCOUNT FROM WORKER GROUP BY DEPARTMENT HAVING COUNT(DEPARTMENT)<3;

--Q41. SHOW ALL DEPATMENT ALONG WITH THEIR NUMBER OF PEOPLE IN THERE
SELECT DEPARTMENT , COUNT(DEPARTMENT) AS DEPCOUNT FROM WORKER 
GROUP BY DEPARTMENT;

--Q42. SHOW LAST RECORD
SELECT * FROM WORKER WHERE WORKER_ID =(SELECT MAX(WORKER_ID) FROM WORKER);

--Q43. FETCH FIRST ROW 
SELECT * FROM WORKER WHERE WORKER_ID =(SELECT MIN(WORKER_ID) FROM WORKER);

--Q44. LAST FIVE RECORDS
SELECT * FROM (
        SELECT * FROM WORKER 
        ORDER BY WORKER_ID DESC 
        FETCH FIRST 5 ROWS ONLY
    ) ORDER BY WORKER_ID;

--Q45 QUERY TO  PRINT THE NAME OF EMPLOYEE HAVING THE HIGHEST SALARY IN THE DEPARTMENT 
SELECT W.DEPARTMENT, W.FIRST_NAME, W.SALARY FROM  (
        SELECT MAX(SALARY)AS MAX_SALARY, DEPARTMENT FROM WORKER 
        GROUP BY DEPARTMENT ) TEMP
INNER JOIN 
    WORKER W ON 
    TEMP.DEPARTMENT= W.DEPARTMENT AND TEMP.MAX_SALARY= W.SALARY;

--Q46. TREEE MAX SALARY USING CORELATED SALARY
 SELECT DISTINCT SALARY FROM WORKER W1 
    WHERE 3>= (SELECT COUNT(DISTINCT SALARY)FROM WORKER W2 
                    WHERE W1.SALARY<=W2.SALARY)
    ORDER BY W1.SALARY DESC;
    -- USING LIMIT 
SELECT DISTINCT SALARY FROM WORKER ORDER BY SALARY DESC FETCH FIRST 3 ROWS ONLY;

--Q47.THREE MINIMUM SALARY USING CO REALTED 
 SELECT DISTINCT SALARY FROM WORKER W1 
    WHERE 3>= (SELECT COUNT(DISTINCT SALARY)FROM WORKER W2 
                    WHERE W1.SALARY>=W2.SALARY)
    ORDER BY W1.SALARY;
    
--Q48. FETCH N-MAX SALARY FROM TABLE 
SELECT DISTINCT SALARY FROM WORKER W1 
    WHERE N>= (SELECT COUNT(DISTINCT SALARY)FROM WORKER W2 
                    WHERE W1.SALARY<=W2.SALARY)
    ORDER BY W1.SALARY DESC;
    
--Q49. QUERY TO FETCH DEPARTMENT ALONG WITH TOTAL SALARIES PAID FOR EACH TIME.
SELECT DEPARTMENT , SUM(SALARY) AS DEP_SALARY FROM WORKER 
    GROUP BY DEPARTMENT 
        ORDER BY SUM(SALARY) DESC;
    
--Q50. QUERY TO WRITE NAMES OF WORKERS THAT EARN HIGHRST SALARY 
SELECT FIRST_NAME, SALARY FROM WORKER 
    WHERE SALARY=(SELECT MAX(SALARY)FROM WORKER);
    
--Q51. REMOVE ALL THE REVERSED NUMBER PAIRS FROM GIVEN TABLES.
CREATE DATABASE TEMP; 
USE TEMP;
CREATE TABLE PAIRS(
    A INT,
    B INT
);
INSERT ALL
    INTO PAIRS VALUES (1,2)
    INTO PAIRS VALUES (2,4)
    INTO PAIRS VALUES (2,1)
    INTO PAIRS VALUES (3,2)
    INTO PAIRS VALUES (4,2)
    INTO PAIRS VALUES (5,6)
    INTO PAIRS VALUES (6,5)
    INTO PAIRS VALUES (7,8)
SELECT 1 FROM DUAL;
SELECT * FROM PAIRS;
TRUNCATE TABLE PAIRS;

--REMOVE REVERSED PAIRS
--METHOD: USING JOINS 

SELECT LT.* FROM PAIRS LT 
    LEFT JOIN PAIRS RT 
        ON LT.A=RT.B AND RT.B=LT.A
    WHERE RT.A IS NULL OR LT.A<RT.A;
    
    SELECT DISTINCT 
    CASE WHEN A < B THEN A ELSE B END AS A, 
    CASE WHEN A < B THEN B ELSE A END AS B
FROM PAIRS;

--  method2: CORELATED UERY 
 SELECT * FROM PAIRS P1 WHERE NOT EXISTS 
 (SELECT * FROM PAIRS P2 WHERE P1.A=P2.B AND P2.A= P1.B AND P1.A > P2.A)
 ORDER BY A ;